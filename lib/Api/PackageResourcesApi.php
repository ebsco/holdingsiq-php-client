<?php
/**
 * PackageResourcesApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
* EBSCO HoldingsIQ
 *
* The EBSCO HoldingsIQ service retrieves vendor, package and title related information in JSON format.  The information includes customer selected resources as reflected in the EBSCO Knowledge Base for both EBSCO managed and customer managed resources.
 *
* OpenAPI spec version: 1.0.0
 * Contact: support@ebsco.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.4
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * PackageResourcesApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PackageResourcesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }
    /**
     * Operation custidPackagesGet
*
* @param  string $custid EBSCO Customer ID (required)
* @param  string $search Keyword search that is applied to limit the results to packages from the vendor that have the search term in the package name. (required)
* @param  string $orderby Valid values are packagename and relevance. Default is relevance. (required)
* @param  int $count The maximum number of results to return in the response. (required)
* @param  int $offset Page Offset (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  string $selection Limits the results.  Valid values are all, selected, notselected, and orderedthroughebsco.  It is also valid to use 0 for all, 1 for selected, 2 for not selected or 3 for ordered through EBSCO.  When you filter by all(0), the total results count takes selected and not selected into consideration. (optional)
* @param  string $contenttype Limits the results by type of package content.  Valid values are all, aggregatedfulltext, abstractandindex, ebook, ejournal, print, unknown and onlinereference.  It is also valid to use 0 for all, 1 for aggregated full text, 2 for abstract and index, 3 for ebook, 4 for ejournal, 5 for print, 6 for unknown or 7 for online reference. (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Packages
     */
    public function custidPackagesGet($custid, $search, $orderby, $count, $offset, $x_api_key, $selection = null, $contenttype = null)
    {
        list($response) = $this->custidPackagesGetWithHttpInfo($custid, $search, $orderby, $count, $offset, $x_api_key, $selection, $contenttype);
        return $response;
    }

    /**
     * Operation custidPackagesGetWithHttpInfo
*
* @param  string $custid EBSCO Customer ID (required)
* @param  string $search Keyword search that is applied to limit the results to packages from the vendor that have the search term in the package name. (required)
* @param  string $orderby Valid values are packagename and relevance. Default is relevance. (required)
* @param  int $count The maximum number of results to return in the response. (required)
* @param  int $offset Page Offset (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  string $selection Limits the results.  Valid values are all, selected, notselected, and orderedthroughebsco.  It is also valid to use 0 for all, 1 for selected, 2 for not selected or 3 for ordered through EBSCO.  When you filter by all(0), the total results count takes selected and not selected into consideration. (optional)
* @param  string $contenttype Limits the results by type of package content.  Valid values are all, aggregatedfulltext, abstractandindex, ebook, ejournal, print, unknown and onlinereference.  It is also valid to use 0 for all, 1 for aggregated full text, 2 for abstract and index, 3 for ebook, 4 for ejournal, 5 for print, 6 for unknown or 7 for online reference. (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Packages, HTTP status code, HTTP response headers (array of strings)
     */
    public function custidPackagesGetWithHttpInfo($custid, $search, $orderby, $count, $offset, $x_api_key, $selection = null, $contenttype = null)
    {
        $returnType = '\Swagger\Client\Model\Packages';
        $request = $this->custidPackagesGetRequest($custid, $search, $orderby, $count, $offset, $x_api_key, $selection, $contenttype);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

$responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];


        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 200:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\Packages',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
case 0:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\Errors',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation custidPackagesGetAsync
     *
     * 
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  string $search Keyword search that is applied to limit the results to packages from the vendor that have the search term in the package name. (required)
* @param  string $orderby Valid values are packagename and relevance. Default is relevance. (required)
* @param  int $count The maximum number of results to return in the response. (required)
* @param  int $offset Page Offset (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  string $selection Limits the results.  Valid values are all, selected, notselected, and orderedthroughebsco.  It is also valid to use 0 for all, 1 for selected, 2 for not selected or 3 for ordered through EBSCO.  When you filter by all(0), the total results count takes selected and not selected into consideration. (optional)
* @param  string $contenttype Limits the results by type of package content.  Valid values are all, aggregatedfulltext, abstractandindex, ebook, ejournal, print, unknown and onlinereference.  It is also valid to use 0 for all, 1 for aggregated full text, 2 for abstract and index, 3 for ebook, 4 for ejournal, 5 for print, 6 for unknown or 7 for online reference. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidPackagesGetAsync($custid, $search, $orderby, $count, $offset, $x_api_key, $selection = null, $contenttype = null)
    {
        return $this->custidPackagesGetAsyncWithHttpInfo($custid, $search, $orderby, $count, $offset, $x_api_key, $selection, $contenttype)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation custidPackagesGetAsyncWithHttpInfo
     *
     * 
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  string $search Keyword search that is applied to limit the results to packages from the vendor that have the search term in the package name. (required)
* @param  string $orderby Valid values are packagename and relevance. Default is relevance. (required)
* @param  int $count The maximum number of results to return in the response. (required)
* @param  int $offset Page Offset (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  string $selection Limits the results.  Valid values are all, selected, notselected, and orderedthroughebsco.  It is also valid to use 0 for all, 1 for selected, 2 for not selected or 3 for ordered through EBSCO.  When you filter by all(0), the total results count takes selected and not selected into consideration. (optional)
* @param  string $contenttype Limits the results by type of package content.  Valid values are all, aggregatedfulltext, abstractandindex, ebook, ejournal, print, unknown and onlinereference.  It is also valid to use 0 for all, 1 for aggregated full text, 2 for abstract and index, 3 for ebook, 4 for ejournal, 5 for print, 6 for unknown or 7 for online reference. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidPackagesGetAsyncWithHttpInfo($custid, $search, $orderby, $count, $offset, $x_api_key, $selection = null, $contenttype = null)
    {
        $returnType = '\Swagger\Client\Model\Packages';
        $request = $this->custidPackagesGetRequest($custid, $search, $orderby, $count, $offset, $x_api_key, $selection, $contenttype);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
$responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'custidPackagesGet'
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  string $search Keyword search that is applied to limit the results to packages from the vendor that have the search term in the package name. (required)
* @param  string $orderby Valid values are packagename and relevance. Default is relevance. (required)
* @param  int $count The maximum number of results to return in the response. (required)
* @param  int $offset Page Offset (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  string $selection Limits the results.  Valid values are all, selected, notselected, and orderedthroughebsco.  It is also valid to use 0 for all, 1 for selected, 2 for not selected or 3 for ordered through EBSCO.  When you filter by all(0), the total results count takes selected and not selected into consideration. (optional)
* @param  string $contenttype Limits the results by type of package content.  Valid values are all, aggregatedfulltext, abstractandindex, ebook, ejournal, print, unknown and onlinereference.  It is also valid to use 0 for all, 1 for aggregated full text, 2 for abstract and index, 3 for ebook, 4 for ejournal, 5 for print, 6 for unknown or 7 for online reference. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function custidPackagesGetRequest($custid, $search, $orderby, $count, $offset, $x_api_key, $selection = null, $contenttype = null)
    {
// verify the required parameter 'custid' is set
        if ($custid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custid when calling custidPackagesGet'
            );
        }
// verify the required parameter 'search' is set
        if ($search === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $search when calling custidPackagesGet'
            );
        }
// verify the required parameter 'orderby' is set
        if ($orderby === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $orderby when calling custidPackagesGet'
            );
        }
// verify the required parameter 'count' is set
        if ($count === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling custidPackagesGet'
            );
        }
// verify the required parameter 'offset' is set
        if ($offset === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling custidPackagesGet'
            );
        }
// verify the required parameter 'x_api_key' is set
        if ($x_api_key === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_api_key when calling custidPackagesGet'
            );
        }
$resourcePath = '/{custid}/packages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// query params
if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search);
        }
// query params
if ($selection !== null) {
            $queryParams['selection'] = ObjectSerializer::toQueryValue($selection);
        }
// query params
if ($contenttype !== null) {
            $queryParams['contenttype'] = ObjectSerializer::toQueryValue($contenttype);
        }
// query params
if ($orderby !== null) {
            $queryParams['orderby'] = ObjectSerializer::toQueryValue($orderby);
        }
// query params
if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count);
        }
// query params
if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
// header params
if ($x_api_key !== null) {
            $headerParams['x-api-key'] = ObjectSerializer::toHeaderValue($x_api_key);
        }
// path params
if ($custid !== null) {
            $resourcePath = str_replace(
                '{' . 'custid' . '}',
                ObjectSerializer::toPathValue($custid),
                $resourcePath
            );
        }
// body params
        $_tempBody = null;
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidGet
*
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PackageIdDetails
     */
    public function custidVendorsVendoridPackagesPackageidGet($vendorid, $packageid, $custid, $x_api_key)
    {
        list($response) = $this->custidVendorsVendoridPackagesPackageidGetWithHttpInfo($vendorid, $packageid, $custid, $x_api_key);
        return $response;
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidGetWithHttpInfo
*
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PackageIdDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function custidVendorsVendoridPackagesPackageidGetWithHttpInfo($vendorid, $packageid, $custid, $x_api_key)
    {
        $returnType = '\Swagger\Client\Model\PackageIdDetails';
        $request = $this->custidVendorsVendoridPackagesPackageidGetRequest($vendorid, $packageid, $custid, $x_api_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

$responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];


        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 200:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\PackageIdDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
case 0:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\Errors',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidGetAsync
     *
     * 
     *
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidVendorsVendoridPackagesPackageidGetAsync($vendorid, $packageid, $custid, $x_api_key)
    {
        return $this->custidVendorsVendoridPackagesPackageidGetAsyncWithHttpInfo($vendorid, $packageid, $custid, $x_api_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidGetAsyncWithHttpInfo
     *
     * 
     *
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidVendorsVendoridPackagesPackageidGetAsyncWithHttpInfo($vendorid, $packageid, $custid, $x_api_key)
    {
        $returnType = '\Swagger\Client\Model\PackageIdDetails';
        $request = $this->custidVendorsVendoridPackagesPackageidGetRequest($vendorid, $packageid, $custid, $x_api_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
$responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'custidVendorsVendoridPackagesPackageidGet'
     *
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function custidVendorsVendoridPackagesPackageidGetRequest($vendorid, $packageid, $custid, $x_api_key)
    {
// verify the required parameter 'vendorid' is set
        if ($vendorid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendorid when calling custidVendorsVendoridPackagesPackageidGet'
            );
        }
// verify the required parameter 'packageid' is set
        if ($packageid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $packageid when calling custidVendorsVendoridPackagesPackageidGet'
            );
        }
// verify the required parameter 'custid' is set
        if ($custid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custid when calling custidVendorsVendoridPackagesPackageidGet'
            );
        }
// verify the required parameter 'x_api_key' is set
        if ($x_api_key === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_api_key when calling custidVendorsVendoridPackagesPackageidGet'
            );
        }
$resourcePath = '/{custid}/vendors/{vendorid}/packages/{packageid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// header params
if ($x_api_key !== null) {
            $headerParams['x-api-key'] = ObjectSerializer::toHeaderValue($x_api_key);
        }
// path params
if ($vendorid !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorid' . '}',
                ObjectSerializer::toPathValue($vendorid),
                $resourcePath
            );
        }
// path params
if ($packageid !== null) {
            $resourcePath = str_replace(
                '{' . 'packageid' . '}',
                ObjectSerializer::toPathValue($packageid),
                $resourcePath
            );
        }
// path params
if ($custid !== null) {
            $resourcePath = str_replace(
                '{' . 'custid' . '}',
                ObjectSerializer::toPathValue($custid),
                $resourcePath
            );
        }
// body params
        $_tempBody = null;
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidPut
*
* @param  string $custid EBSCO Customer ID (required)
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\UpdatePackageNonInheritedProxyPayload $body JSON payload to update a package with a proxy. (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function custidVendorsVendoridPackagesPackageidPut($custid, $vendorid, $packageid, $x_api_key, $body = null)
    {
        $this->custidVendorsVendoridPackagesPackageidPutWithHttpInfo($custid, $vendorid, $packageid, $x_api_key, $body);
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidPutWithHttpInfo
*
* @param  string $custid EBSCO Customer ID (required)
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\UpdatePackageNonInheritedProxyPayload $body JSON payload to update a package with a proxy. (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function custidVendorsVendoridPackagesPackageidPutWithHttpInfo($custid, $vendorid, $packageid, $x_api_key, $body = null)
    {
        $returnType = '';
        $request = $this->custidVendorsVendoridPackagesPackageidPutRequest($custid, $vendorid, $packageid, $x_api_key, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 0:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\Errors',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidPutAsync
     *
     * 
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\UpdatePackageNonInheritedProxyPayload $body JSON payload to update a package with a proxy. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidVendorsVendoridPackagesPackageidPutAsync($custid, $vendorid, $packageid, $x_api_key, $body = null)
    {
        return $this->custidVendorsVendoridPackagesPackageidPutAsyncWithHttpInfo($custid, $vendorid, $packageid, $x_api_key, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidPutAsyncWithHttpInfo
     *
     * 
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\UpdatePackageNonInheritedProxyPayload $body JSON payload to update a package with a proxy. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidVendorsVendoridPackagesPackageidPutAsyncWithHttpInfo($custid, $vendorid, $packageid, $x_api_key, $body = null)
    {
        $returnType = '';
        $request = $this->custidVendorsVendoridPackagesPackageidPutRequest($custid, $vendorid, $packageid, $x_api_key, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'custidVendorsVendoridPackagesPackageidPut'
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\UpdatePackageNonInheritedProxyPayload $body JSON payload to update a package with a proxy. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function custidVendorsVendoridPackagesPackageidPutRequest($custid, $vendorid, $packageid, $x_api_key, $body = null)
    {
// verify the required parameter 'custid' is set
        if ($custid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custid when calling custidVendorsVendoridPackagesPackageidPut'
            );
        }
// verify the required parameter 'vendorid' is set
        if ($vendorid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendorid when calling custidVendorsVendoridPackagesPackageidPut'
            );
        }
// verify the required parameter 'packageid' is set
        if ($packageid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $packageid when calling custidVendorsVendoridPackagesPackageidPut'
            );
        }
// verify the required parameter 'x_api_key' is set
        if ($x_api_key === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_api_key when calling custidVendorsVendoridPackagesPackageidPut'
            );
        }
$resourcePath = '/{custid}/vendors/{vendorid}/packages/{packageid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// header params
if ($x_api_key !== null) {
            $headerParams['x-api-key'] = ObjectSerializer::toHeaderValue($x_api_key);
        }
// path params
if ($custid !== null) {
            $resourcePath = str_replace(
                '{' . 'custid' . '}',
                ObjectSerializer::toPathValue($custid),
                $resourcePath
            );
        }
// path params
if ($vendorid !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorid' . '}',
                ObjectSerializer::toPathValue($vendorid),
                $resourcePath
            );
        }
// path params
if ($packageid !== null) {
            $resourcePath = str_replace(
                '{' . 'packageid' . '}',
                ObjectSerializer::toPathValue($packageid),
                $resourcePath
            );
        }
// body params
        $_tempBody = null;
if (isset($body)) {
            $_tempBody = $body;
        }
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidTitlesGet
*
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $searchfield Field to search.  Valid values are titlename, publisher, isxn, and subject.  It is also valid to use 0 for title name, 1 for publisher, 2 for isxn or 3 for subject. (required)
* @param  string $orderby Valid values are relevance and titlename.  Default is relevance. (required)
* @param  int $count The maximum number of results to return in the response. (required)
* @param  int $offset Page Offset (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  string $search Keyword search that is applied to limit the results to titles from the package that have the search term in the search field.  When searching for titles without a search parameter, the sort options will be by titlename. When the search parameter is not null, then the default sort is by relevance. (optional)
* @param  string $selection Limits the results.  Valid values are all, selected, notselected and orderedthroughebsco.  It is also valid to use 0 for all, 1 for selected, 2 for notselected, or 3 for ordered through EBSCO.  When you filter by all(0), the total results count takes selected and not selected into consideration. (optional)
* @param  string $resourcetype Type of resource. Valid values are all, journal, newsletter, report, proceedings, website, newspaper, unspecified, book, bookseries, database, thesisdissertation, streamingaudio, streamingvideo, and audiobook.  It is also valid to use 0 for all, 1 for journal, 2 for newsletter, 3 for report, 4 for proceedings, 5 for website, 6 for newspaper, 7 for unspecified, 8 for book, 9 for book series, 10 for database, 11 for thesis dissertation, 12 for streaming audio, 13 for streaming video, or 14 for audio book. (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TitlesPackageId
     */
    public function custidVendorsVendoridPackagesPackageidTitlesGet($vendorid, $packageid, $custid, $searchfield, $orderby, $count, $offset, $x_api_key, $search = null, $selection = null, $resourcetype = null)
    {
        list($response) = $this->custidVendorsVendoridPackagesPackageidTitlesGetWithHttpInfo($vendorid, $packageid, $custid, $searchfield, $orderby, $count, $offset, $x_api_key, $search, $selection, $resourcetype);
        return $response;
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidTitlesGetWithHttpInfo
*
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $searchfield Field to search.  Valid values are titlename, publisher, isxn, and subject.  It is also valid to use 0 for title name, 1 for publisher, 2 for isxn or 3 for subject. (required)
* @param  string $orderby Valid values are relevance and titlename.  Default is relevance. (required)
* @param  int $count The maximum number of results to return in the response. (required)
* @param  int $offset Page Offset (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  string $search Keyword search that is applied to limit the results to titles from the package that have the search term in the search field.  When searching for titles without a search parameter, the sort options will be by titlename. When the search parameter is not null, then the default sort is by relevance. (optional)
* @param  string $selection Limits the results.  Valid values are all, selected, notselected and orderedthroughebsco.  It is also valid to use 0 for all, 1 for selected, 2 for notselected, or 3 for ordered through EBSCO.  When you filter by all(0), the total results count takes selected and not selected into consideration. (optional)
* @param  string $resourcetype Type of resource. Valid values are all, journal, newsletter, report, proceedings, website, newspaper, unspecified, book, bookseries, database, thesisdissertation, streamingaudio, streamingvideo, and audiobook.  It is also valid to use 0 for all, 1 for journal, 2 for newsletter, 3 for report, 4 for proceedings, 5 for website, 6 for newspaper, 7 for unspecified, 8 for book, 9 for book series, 10 for database, 11 for thesis dissertation, 12 for streaming audio, 13 for streaming video, or 14 for audio book. (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TitlesPackageId, HTTP status code, HTTP response headers (array of strings)
     */
    public function custidVendorsVendoridPackagesPackageidTitlesGetWithHttpInfo($vendorid, $packageid, $custid, $searchfield, $orderby, $count, $offset, $x_api_key, $search = null, $selection = null, $resourcetype = null)
    {
        $returnType = '\Swagger\Client\Model\TitlesPackageId';
        $request = $this->custidVendorsVendoridPackagesPackageidTitlesGetRequest($vendorid, $packageid, $custid, $searchfield, $orderby, $count, $offset, $x_api_key, $search, $selection, $resourcetype);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

$responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];


        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 200:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\TitlesPackageId',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
case 0:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\Errors',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidTitlesGetAsync
     *
     * 
     *
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $searchfield Field to search.  Valid values are titlename, publisher, isxn, and subject.  It is also valid to use 0 for title name, 1 for publisher, 2 for isxn or 3 for subject. (required)
* @param  string $orderby Valid values are relevance and titlename.  Default is relevance. (required)
* @param  int $count The maximum number of results to return in the response. (required)
* @param  int $offset Page Offset (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  string $search Keyword search that is applied to limit the results to titles from the package that have the search term in the search field.  When searching for titles without a search parameter, the sort options will be by titlename. When the search parameter is not null, then the default sort is by relevance. (optional)
* @param  string $selection Limits the results.  Valid values are all, selected, notselected and orderedthroughebsco.  It is also valid to use 0 for all, 1 for selected, 2 for notselected, or 3 for ordered through EBSCO.  When you filter by all(0), the total results count takes selected and not selected into consideration. (optional)
* @param  string $resourcetype Type of resource. Valid values are all, journal, newsletter, report, proceedings, website, newspaper, unspecified, book, bookseries, database, thesisdissertation, streamingaudio, streamingvideo, and audiobook.  It is also valid to use 0 for all, 1 for journal, 2 for newsletter, 3 for report, 4 for proceedings, 5 for website, 6 for newspaper, 7 for unspecified, 8 for book, 9 for book series, 10 for database, 11 for thesis dissertation, 12 for streaming audio, 13 for streaming video, or 14 for audio book. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidVendorsVendoridPackagesPackageidTitlesGetAsync($vendorid, $packageid, $custid, $searchfield, $orderby, $count, $offset, $x_api_key, $search = null, $selection = null, $resourcetype = null)
    {
        return $this->custidVendorsVendoridPackagesPackageidTitlesGetAsyncWithHttpInfo($vendorid, $packageid, $custid, $searchfield, $orderby, $count, $offset, $x_api_key, $search, $selection, $resourcetype)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidTitlesGetAsyncWithHttpInfo
     *
     * 
     *
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $searchfield Field to search.  Valid values are titlename, publisher, isxn, and subject.  It is also valid to use 0 for title name, 1 for publisher, 2 for isxn or 3 for subject. (required)
* @param  string $orderby Valid values are relevance and titlename.  Default is relevance. (required)
* @param  int $count The maximum number of results to return in the response. (required)
* @param  int $offset Page Offset (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  string $search Keyword search that is applied to limit the results to titles from the package that have the search term in the search field.  When searching for titles without a search parameter, the sort options will be by titlename. When the search parameter is not null, then the default sort is by relevance. (optional)
* @param  string $selection Limits the results.  Valid values are all, selected, notselected and orderedthroughebsco.  It is also valid to use 0 for all, 1 for selected, 2 for notselected, or 3 for ordered through EBSCO.  When you filter by all(0), the total results count takes selected and not selected into consideration. (optional)
* @param  string $resourcetype Type of resource. Valid values are all, journal, newsletter, report, proceedings, website, newspaper, unspecified, book, bookseries, database, thesisdissertation, streamingaudio, streamingvideo, and audiobook.  It is also valid to use 0 for all, 1 for journal, 2 for newsletter, 3 for report, 4 for proceedings, 5 for website, 6 for newspaper, 7 for unspecified, 8 for book, 9 for book series, 10 for database, 11 for thesis dissertation, 12 for streaming audio, 13 for streaming video, or 14 for audio book. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidVendorsVendoridPackagesPackageidTitlesGetAsyncWithHttpInfo($vendorid, $packageid, $custid, $searchfield, $orderby, $count, $offset, $x_api_key, $search = null, $selection = null, $resourcetype = null)
    {
        $returnType = '\Swagger\Client\Model\TitlesPackageId';
        $request = $this->custidVendorsVendoridPackagesPackageidTitlesGetRequest($vendorid, $packageid, $custid, $searchfield, $orderby, $count, $offset, $x_api_key, $search, $selection, $resourcetype);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
$responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'custidVendorsVendoridPackagesPackageidTitlesGet'
     *
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $searchfield Field to search.  Valid values are titlename, publisher, isxn, and subject.  It is also valid to use 0 for title name, 1 for publisher, 2 for isxn or 3 for subject. (required)
* @param  string $orderby Valid values are relevance and titlename.  Default is relevance. (required)
* @param  int $count The maximum number of results to return in the response. (required)
* @param  int $offset Page Offset (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  string $search Keyword search that is applied to limit the results to titles from the package that have the search term in the search field.  When searching for titles without a search parameter, the sort options will be by titlename. When the search parameter is not null, then the default sort is by relevance. (optional)
* @param  string $selection Limits the results.  Valid values are all, selected, notselected and orderedthroughebsco.  It is also valid to use 0 for all, 1 for selected, 2 for notselected, or 3 for ordered through EBSCO.  When you filter by all(0), the total results count takes selected and not selected into consideration. (optional)
* @param  string $resourcetype Type of resource. Valid values are all, journal, newsletter, report, proceedings, website, newspaper, unspecified, book, bookseries, database, thesisdissertation, streamingaudio, streamingvideo, and audiobook.  It is also valid to use 0 for all, 1 for journal, 2 for newsletter, 3 for report, 4 for proceedings, 5 for website, 6 for newspaper, 7 for unspecified, 8 for book, 9 for book series, 10 for database, 11 for thesis dissertation, 12 for streaming audio, 13 for streaming video, or 14 for audio book. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function custidVendorsVendoridPackagesPackageidTitlesGetRequest($vendorid, $packageid, $custid, $searchfield, $orderby, $count, $offset, $x_api_key, $search = null, $selection = null, $resourcetype = null)
    {
// verify the required parameter 'vendorid' is set
        if ($vendorid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendorid when calling custidVendorsVendoridPackagesPackageidTitlesGet'
            );
        }
// verify the required parameter 'packageid' is set
        if ($packageid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $packageid when calling custidVendorsVendoridPackagesPackageidTitlesGet'
            );
        }
// verify the required parameter 'custid' is set
        if ($custid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custid when calling custidVendorsVendoridPackagesPackageidTitlesGet'
            );
        }
// verify the required parameter 'searchfield' is set
        if ($searchfield === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchfield when calling custidVendorsVendoridPackagesPackageidTitlesGet'
            );
        }
// verify the required parameter 'orderby' is set
        if ($orderby === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $orderby when calling custidVendorsVendoridPackagesPackageidTitlesGet'
            );
        }
// verify the required parameter 'count' is set
        if ($count === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling custidVendorsVendoridPackagesPackageidTitlesGet'
            );
        }
// verify the required parameter 'offset' is set
        if ($offset === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling custidVendorsVendoridPackagesPackageidTitlesGet'
            );
        }
// verify the required parameter 'x_api_key' is set
        if ($x_api_key === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_api_key when calling custidVendorsVendoridPackagesPackageidTitlesGet'
            );
        }
$resourcePath = '/{custid}/vendors/{vendorid}/packages/{packageid}/titles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// query params
if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search);
        }
// query params
if ($searchfield !== null) {
            $queryParams['searchfield'] = ObjectSerializer::toQueryValue($searchfield);
        }
// query params
if ($selection !== null) {
            $queryParams['selection'] = ObjectSerializer::toQueryValue($selection);
        }
// query params
if ($resourcetype !== null) {
            $queryParams['resourcetype'] = ObjectSerializer::toQueryValue($resourcetype);
        }
// query params
if ($orderby !== null) {
            $queryParams['orderby'] = ObjectSerializer::toQueryValue($orderby);
        }
// query params
if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count);
        }
// query params
if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
// header params
if ($x_api_key !== null) {
            $headerParams['x-api-key'] = ObjectSerializer::toHeaderValue($x_api_key);
        }
// path params
if ($vendorid !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorid' . '}',
                ObjectSerializer::toPathValue($vendorid),
                $resourcePath
            );
        }
// path params
if ($packageid !== null) {
            $resourcePath = str_replace(
                '{' . 'packageid' . '}',
                ObjectSerializer::toPathValue($packageid),
                $resourcePath
            );
        }
// path params
if ($custid !== null) {
            $resourcePath = str_replace(
                '{' . 'custid' . '}',
                ObjectSerializer::toPathValue($custid),
                $resourcePath
            );
        }
// body params
        $_tempBody = null;
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidTitlesKbidGet
*
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  int $kbid Title ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TitleManaged
     */
    public function custidVendorsVendoridPackagesPackageidTitlesKbidGet($vendorid, $packageid, $kbid, $custid, $x_api_key)
    {
        list($response) = $this->custidVendorsVendoridPackagesPackageidTitlesKbidGetWithHttpInfo($vendorid, $packageid, $kbid, $custid, $x_api_key);
        return $response;
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidTitlesKbidGetWithHttpInfo
*
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  int $kbid Title ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TitleManaged, HTTP status code, HTTP response headers (array of strings)
     */
    public function custidVendorsVendoridPackagesPackageidTitlesKbidGetWithHttpInfo($vendorid, $packageid, $kbid, $custid, $x_api_key)
    {
        $returnType = '\Swagger\Client\Model\TitleManaged';
        $request = $this->custidVendorsVendoridPackagesPackageidTitlesKbidGetRequest($vendorid, $packageid, $kbid, $custid, $x_api_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

$responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];


        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 200:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\TitleManaged',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
case 200 :$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\TitleCustom',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
case 0:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\Errors',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidTitlesKbidGetAsync
     *
     * 
     *
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  int $kbid Title ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidVendorsVendoridPackagesPackageidTitlesKbidGetAsync($vendorid, $packageid, $kbid, $custid, $x_api_key)
    {
        return $this->custidVendorsVendoridPackagesPackageidTitlesKbidGetAsyncWithHttpInfo($vendorid, $packageid, $kbid, $custid, $x_api_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidTitlesKbidGetAsyncWithHttpInfo
     *
     * 
     *
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  int $kbid Title ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidVendorsVendoridPackagesPackageidTitlesKbidGetAsyncWithHttpInfo($vendorid, $packageid, $kbid, $custid, $x_api_key)
    {
        $returnType = '\Swagger\Client\Model\TitleManaged';
        $request = $this->custidVendorsVendoridPackagesPackageidTitlesKbidGetRequest($vendorid, $packageid, $kbid, $custid, $x_api_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
$responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'custidVendorsVendoridPackagesPackageidTitlesKbidGet'
     *
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  int $kbid Title ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function custidVendorsVendoridPackagesPackageidTitlesKbidGetRequest($vendorid, $packageid, $kbid, $custid, $x_api_key)
    {
// verify the required parameter 'vendorid' is set
        if ($vendorid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendorid when calling custidVendorsVendoridPackagesPackageidTitlesKbidGet'
            );
        }
// verify the required parameter 'packageid' is set
        if ($packageid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $packageid when calling custidVendorsVendoridPackagesPackageidTitlesKbidGet'
            );
        }
// verify the required parameter 'kbid' is set
        if ($kbid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $kbid when calling custidVendorsVendoridPackagesPackageidTitlesKbidGet'
            );
        }
// verify the required parameter 'custid' is set
        if ($custid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custid when calling custidVendorsVendoridPackagesPackageidTitlesKbidGet'
            );
        }
// verify the required parameter 'x_api_key' is set
        if ($x_api_key === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_api_key when calling custidVendorsVendoridPackagesPackageidTitlesKbidGet'
            );
        }
$resourcePath = '/{custid}/vendors/{vendorid}/packages/{packageid}/titles/{kbid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// header params
if ($x_api_key !== null) {
            $headerParams['x-api-key'] = ObjectSerializer::toHeaderValue($x_api_key);
        }
// path params
if ($vendorid !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorid' . '}',
                ObjectSerializer::toPathValue($vendorid),
                $resourcePath
            );
        }
// path params
if ($packageid !== null) {
            $resourcePath = str_replace(
                '{' . 'packageid' . '}',
                ObjectSerializer::toPathValue($packageid),
                $resourcePath
            );
        }
// path params
if ($kbid !== null) {
            $resourcePath = str_replace(
                '{' . 'kbid' . '}',
                ObjectSerializer::toPathValue($kbid),
                $resourcePath
            );
        }
// path params
if ($custid !== null) {
            $resourcePath = str_replace(
                '{' . 'custid' . '}',
                ObjectSerializer::toPathValue($custid),
                $resourcePath
            );
        }
// body params
        $_tempBody = null;
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidTitlesKbidPut
*
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  int $kbid Title ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\SetProxyInPayload $body JSON payload to update the inherited proxy value for a custom title. (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function custidVendorsVendoridPackagesPackageidTitlesKbidPut($vendorid, $packageid, $kbid, $custid, $x_api_key, $body = null)
    {
        $this->custidVendorsVendoridPackagesPackageidTitlesKbidPutWithHttpInfo($vendorid, $packageid, $kbid, $custid, $x_api_key, $body);
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidTitlesKbidPutWithHttpInfo
*
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  int $kbid Title ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\SetProxyInPayload $body JSON payload to update the inherited proxy value for a custom title. (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function custidVendorsVendoridPackagesPackageidTitlesKbidPutWithHttpInfo($vendorid, $packageid, $kbid, $custid, $x_api_key, $body = null)
    {
        $returnType = '';
        $request = $this->custidVendorsVendoridPackagesPackageidTitlesKbidPutRequest($vendorid, $packageid, $kbid, $custid, $x_api_key, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 0:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\Errors',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidTitlesKbidPutAsync
     *
     * 
     *
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  int $kbid Title ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\SetProxyInPayload $body JSON payload to update the inherited proxy value for a custom title. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidVendorsVendoridPackagesPackageidTitlesKbidPutAsync($vendorid, $packageid, $kbid, $custid, $x_api_key, $body = null)
    {
        return $this->custidVendorsVendoridPackagesPackageidTitlesKbidPutAsyncWithHttpInfo($vendorid, $packageid, $kbid, $custid, $x_api_key, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidTitlesKbidPutAsyncWithHttpInfo
     *
     * 
     *
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  int $kbid Title ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\SetProxyInPayload $body JSON payload to update the inherited proxy value for a custom title. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidVendorsVendoridPackagesPackageidTitlesKbidPutAsyncWithHttpInfo($vendorid, $packageid, $kbid, $custid, $x_api_key, $body = null)
    {
        $returnType = '';
        $request = $this->custidVendorsVendoridPackagesPackageidTitlesKbidPutRequest($vendorid, $packageid, $kbid, $custid, $x_api_key, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'custidVendorsVendoridPackagesPackageidTitlesKbidPut'
     *
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  int $kbid Title ID (required)
* @param  string $custid EBSCO Customer ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\SetProxyInPayload $body JSON payload to update the inherited proxy value for a custom title. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function custidVendorsVendoridPackagesPackageidTitlesKbidPutRequest($vendorid, $packageid, $kbid, $custid, $x_api_key, $body = null)
    {
// verify the required parameter 'vendorid' is set
        if ($vendorid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendorid when calling custidVendorsVendoridPackagesPackageidTitlesKbidPut'
            );
        }
// verify the required parameter 'packageid' is set
        if ($packageid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $packageid when calling custidVendorsVendoridPackagesPackageidTitlesKbidPut'
            );
        }
// verify the required parameter 'kbid' is set
        if ($kbid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $kbid when calling custidVendorsVendoridPackagesPackageidTitlesKbidPut'
            );
        }
// verify the required parameter 'custid' is set
        if ($custid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custid when calling custidVendorsVendoridPackagesPackageidTitlesKbidPut'
            );
        }
// verify the required parameter 'x_api_key' is set
        if ($x_api_key === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_api_key when calling custidVendorsVendoridPackagesPackageidTitlesKbidPut'
            );
        }
$resourcePath = '/{custid}/vendors/{vendorid}/packages/{packageid}/titles/{kbid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// header params
if ($x_api_key !== null) {
            $headerParams['x-api-key'] = ObjectSerializer::toHeaderValue($x_api_key);
        }
// path params
if ($vendorid !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorid' . '}',
                ObjectSerializer::toPathValue($vendorid),
                $resourcePath
            );
        }
// path params
if ($packageid !== null) {
            $resourcePath = str_replace(
                '{' . 'packageid' . '}',
                ObjectSerializer::toPathValue($packageid),
                $resourcePath
            );
        }
// path params
if ($kbid !== null) {
            $resourcePath = str_replace(
                '{' . 'kbid' . '}',
                ObjectSerializer::toPathValue($kbid),
                $resourcePath
            );
        }
// path params
if ($custid !== null) {
            $resourcePath = str_replace(
                '{' . 'custid' . '}',
                ObjectSerializer::toPathValue($custid),
                $resourcePath
            );
        }
// body params
        $_tempBody = null;
if (isset($body)) {
            $_tempBody = $body;
        }
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation custidVendorsVendoridPackagesPost
*
* @param  string $custid EBSCO Customer ID (required)
* @param  int $vendorid Vendor ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\CustomPackagePayload $body JSON POST payload.  Specify the packageName in the payload.  Set contentType in the payload to 1 for Agregated Full Text, 2 for Abstract and Index, 3 for Ebook, 4 for E-Journal, 5 for Print, 6 for Unknown or 7 for Online Reference.  Set the custom coverage dates. (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CustomPackageResponse
     */
    public function custidVendorsVendoridPackagesPost($custid, $vendorid, $x_api_key, $body = null)
    {
        list($response) = $this->custidVendorsVendoridPackagesPostWithHttpInfo($custid, $vendorid, $x_api_key, $body);
        return $response;
    }

    /**
     * Operation custidVendorsVendoridPackagesPostWithHttpInfo
*
* @param  string $custid EBSCO Customer ID (required)
* @param  int $vendorid Vendor ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\CustomPackagePayload $body JSON POST payload.  Specify the packageName in the payload.  Set contentType in the payload to 1 for Agregated Full Text, 2 for Abstract and Index, 3 for Ebook, 4 for E-Journal, 5 for Print, 6 for Unknown or 7 for Online Reference.  Set the custom coverage dates. (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CustomPackageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function custidVendorsVendoridPackagesPostWithHttpInfo($custid, $vendorid, $x_api_key, $body = null)
    {
        $returnType = '\Swagger\Client\Model\CustomPackageResponse';
        $request = $this->custidVendorsVendoridPackagesPostRequest($custid, $vendorid, $x_api_key, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

$responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];


        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 200:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\CustomPackageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
case 0:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\Errors',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation custidVendorsVendoridPackagesPostAsync
     *
     * 
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  int $vendorid Vendor ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\CustomPackagePayload $body JSON POST payload.  Specify the packageName in the payload.  Set contentType in the payload to 1 for Agregated Full Text, 2 for Abstract and Index, 3 for Ebook, 4 for E-Journal, 5 for Print, 6 for Unknown or 7 for Online Reference.  Set the custom coverage dates. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidVendorsVendoridPackagesPostAsync($custid, $vendorid, $x_api_key, $body = null)
    {
        return $this->custidVendorsVendoridPackagesPostAsyncWithHttpInfo($custid, $vendorid, $x_api_key, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation custidVendorsVendoridPackagesPostAsyncWithHttpInfo
     *
     * 
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  int $vendorid Vendor ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\CustomPackagePayload $body JSON POST payload.  Specify the packageName in the payload.  Set contentType in the payload to 1 for Agregated Full Text, 2 for Abstract and Index, 3 for Ebook, 4 for E-Journal, 5 for Print, 6 for Unknown or 7 for Online Reference.  Set the custom coverage dates. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidVendorsVendoridPackagesPostAsyncWithHttpInfo($custid, $vendorid, $x_api_key, $body = null)
    {
        $returnType = '\Swagger\Client\Model\CustomPackageResponse';
        $request = $this->custidVendorsVendoridPackagesPostRequest($custid, $vendorid, $x_api_key, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
$responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'custidVendorsVendoridPackagesPost'
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  int $vendorid Vendor ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\CustomPackagePayload $body JSON POST payload.  Specify the packageName in the payload.  Set contentType in the payload to 1 for Agregated Full Text, 2 for Abstract and Index, 3 for Ebook, 4 for E-Journal, 5 for Print, 6 for Unknown or 7 for Online Reference.  Set the custom coverage dates. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function custidVendorsVendoridPackagesPostRequest($custid, $vendorid, $x_api_key, $body = null)
    {
// verify the required parameter 'custid' is set
        if ($custid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custid when calling custidVendorsVendoridPackagesPost'
            );
        }
// verify the required parameter 'vendorid' is set
        if ($vendorid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendorid when calling custidVendorsVendoridPackagesPost'
            );
        }
// verify the required parameter 'x_api_key' is set
        if ($x_api_key === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_api_key when calling custidVendorsVendoridPackagesPost'
            );
        }
$resourcePath = '/{custid}/vendors/{vendorid}/packages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// header params
if ($x_api_key !== null) {
            $headerParams['x-api-key'] = ObjectSerializer::toHeaderValue($x_api_key);
        }
// path params
if ($custid !== null) {
            $resourcePath = str_replace(
                '{' . 'custid' . '}',
                ObjectSerializer::toPathValue($custid),
                $resourcePath
            );
        }
// path params
if ($vendorid !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorid' . '}',
                ObjectSerializer::toPathValue($vendorid),
                $resourcePath
            );
        }
// body params
        $_tempBody = null;
if (isset($body)) {
            $_tempBody = $body;
        }
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

/**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
