<?php
/**
 * TitleResourcesApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
* EBSCO HoldingsIQ
 *
* The EBSCO HoldingsIQ service retrieves vendor, package and title related information in JSON format.  The information includes customer selected resources as reflected in the EBSCO Knowledge Base for both EBSCO managed and customer managed resources.
 *
* OpenAPI spec version: 1.0.0
 * Contact: support@ebsco.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.4
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * TitleResourcesApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TitleResourcesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }
    /**
     * Operation custidTitlesGet
*
* @param  string $custid EBSCO Customer ID (required)
* @param  string $search Search Term.  Keyword search that is applied to limit the results to titles that have the search term in the search field. (required)
* @param  string $searchfield Field to search.  Valid values are titlename, publisher, isxn, and subject.  It is also valid to use 0 for title name, 1 for publisher, 2 for isxn or 3 for subject. (required)
* @param  string $orderby Valid values are relevance or titlename.  Default is relevance. (required)
* @param  int $count The maximum number of results to return in the response. (required)
* @param  int $offset Page Offset (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  string $selection Limits the results.  Valid values are all, selected, notselected and orderedthroughebsco.  It is also valid to use 0 for all, 1 for selected, 2 for notselected, or 3 for ordered through EBSCO.  When you filter by all(0), the total results count takes selected and not selected into consideration. (optional)
* @param  string $resourcetype Type of resource. Valid values are all, journal, newsletter, report, proceedings, website, newspaper, unspecified, book, bookseries, database, thesisdissertation, streamingaudio, streamingvideo, and audiobook.  It is also valid to use 0 for all, 1 for journal, 2 for newsletter, 3 for report, 4 for proceedings, 5 for website, 6 for newspaper, 7 for unspecified, 8 for book, 9 for book series, 10 for database, 11 for thesis dissertation, 12 for streaming audio, 13 for streaming video, or 14 for audio book. (optional)
* @param  string $searchtype Type of search. Search types are any, contains, exactmatch, beginswith, proximity, exactphrase and advanced. It is also valid to use 0 for any, 1 for contains, 2 for exactmatch, 3 for beginswith, 4 for proximity, 5 for exactphrase or 6 for advanced.  searchtype is an optional parameter and defaults to contains if not provided.  For more information on the search types, see [Using Search Types](https://developer.ebsco.com/guides/overviewsearch/) (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Titles
     */
    public function custidTitlesGet($custid, $search, $searchfield, $orderby, $count, $offset, $x_api_key, $selection = null, $resourcetype = null, $searchtype = null)
    {
        list($response) = $this->custidTitlesGetWithHttpInfo($custid, $search, $searchfield, $orderby, $count, $offset, $x_api_key, $selection, $resourcetype, $searchtype);
        return $response;
    }

    /**
     * Operation custidTitlesGetWithHttpInfo
*
* @param  string $custid EBSCO Customer ID (required)
* @param  string $search Search Term.  Keyword search that is applied to limit the results to titles that have the search term in the search field. (required)
* @param  string $searchfield Field to search.  Valid values are titlename, publisher, isxn, and subject.  It is also valid to use 0 for title name, 1 for publisher, 2 for isxn or 3 for subject. (required)
* @param  string $orderby Valid values are relevance or titlename.  Default is relevance. (required)
* @param  int $count The maximum number of results to return in the response. (required)
* @param  int $offset Page Offset (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  string $selection Limits the results.  Valid values are all, selected, notselected and orderedthroughebsco.  It is also valid to use 0 for all, 1 for selected, 2 for notselected, or 3 for ordered through EBSCO.  When you filter by all(0), the total results count takes selected and not selected into consideration. (optional)
* @param  string $resourcetype Type of resource. Valid values are all, journal, newsletter, report, proceedings, website, newspaper, unspecified, book, bookseries, database, thesisdissertation, streamingaudio, streamingvideo, and audiobook.  It is also valid to use 0 for all, 1 for journal, 2 for newsletter, 3 for report, 4 for proceedings, 5 for website, 6 for newspaper, 7 for unspecified, 8 for book, 9 for book series, 10 for database, 11 for thesis dissertation, 12 for streaming audio, 13 for streaming video, or 14 for audio book. (optional)
* @param  string $searchtype Type of search. Search types are any, contains, exactmatch, beginswith, proximity, exactphrase and advanced. It is also valid to use 0 for any, 1 for contains, 2 for exactmatch, 3 for beginswith, 4 for proximity, 5 for exactphrase or 6 for advanced.  searchtype is an optional parameter and defaults to contains if not provided.  For more information on the search types, see [Using Search Types](https://developer.ebsco.com/guides/overviewsearch/) (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Titles, HTTP status code, HTTP response headers (array of strings)
     */
    public function custidTitlesGetWithHttpInfo($custid, $search, $searchfield, $orderby, $count, $offset, $x_api_key, $selection = null, $resourcetype = null, $searchtype = null)
    {
        $returnType = '\Swagger\Client\Model\Titles';
        $request = $this->custidTitlesGetRequest($custid, $search, $searchfield, $orderby, $count, $offset, $x_api_key, $selection, $resourcetype, $searchtype);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

$responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];


        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 200:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\Titles',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
case 0:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\Errors',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation custidTitlesGetAsync
     *
     * 
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  string $search Search Term.  Keyword search that is applied to limit the results to titles that have the search term in the search field. (required)
* @param  string $searchfield Field to search.  Valid values are titlename, publisher, isxn, and subject.  It is also valid to use 0 for title name, 1 for publisher, 2 for isxn or 3 for subject. (required)
* @param  string $orderby Valid values are relevance or titlename.  Default is relevance. (required)
* @param  int $count The maximum number of results to return in the response. (required)
* @param  int $offset Page Offset (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  string $selection Limits the results.  Valid values are all, selected, notselected and orderedthroughebsco.  It is also valid to use 0 for all, 1 for selected, 2 for notselected, or 3 for ordered through EBSCO.  When you filter by all(0), the total results count takes selected and not selected into consideration. (optional)
* @param  string $resourcetype Type of resource. Valid values are all, journal, newsletter, report, proceedings, website, newspaper, unspecified, book, bookseries, database, thesisdissertation, streamingaudio, streamingvideo, and audiobook.  It is also valid to use 0 for all, 1 for journal, 2 for newsletter, 3 for report, 4 for proceedings, 5 for website, 6 for newspaper, 7 for unspecified, 8 for book, 9 for book series, 10 for database, 11 for thesis dissertation, 12 for streaming audio, 13 for streaming video, or 14 for audio book. (optional)
* @param  string $searchtype Type of search. Search types are any, contains, exactmatch, beginswith, proximity, exactphrase and advanced. It is also valid to use 0 for any, 1 for contains, 2 for exactmatch, 3 for beginswith, 4 for proximity, 5 for exactphrase or 6 for advanced.  searchtype is an optional parameter and defaults to contains if not provided.  For more information on the search types, see [Using Search Types](https://developer.ebsco.com/guides/overviewsearch/) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidTitlesGetAsync($custid, $search, $searchfield, $orderby, $count, $offset, $x_api_key, $selection = null, $resourcetype = null, $searchtype = null)
    {
        return $this->custidTitlesGetAsyncWithHttpInfo($custid, $search, $searchfield, $orderby, $count, $offset, $x_api_key, $selection, $resourcetype, $searchtype)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation custidTitlesGetAsyncWithHttpInfo
     *
     * 
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  string $search Search Term.  Keyword search that is applied to limit the results to titles that have the search term in the search field. (required)
* @param  string $searchfield Field to search.  Valid values are titlename, publisher, isxn, and subject.  It is also valid to use 0 for title name, 1 for publisher, 2 for isxn or 3 for subject. (required)
* @param  string $orderby Valid values are relevance or titlename.  Default is relevance. (required)
* @param  int $count The maximum number of results to return in the response. (required)
* @param  int $offset Page Offset (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  string $selection Limits the results.  Valid values are all, selected, notselected and orderedthroughebsco.  It is also valid to use 0 for all, 1 for selected, 2 for notselected, or 3 for ordered through EBSCO.  When you filter by all(0), the total results count takes selected and not selected into consideration. (optional)
* @param  string $resourcetype Type of resource. Valid values are all, journal, newsletter, report, proceedings, website, newspaper, unspecified, book, bookseries, database, thesisdissertation, streamingaudio, streamingvideo, and audiobook.  It is also valid to use 0 for all, 1 for journal, 2 for newsletter, 3 for report, 4 for proceedings, 5 for website, 6 for newspaper, 7 for unspecified, 8 for book, 9 for book series, 10 for database, 11 for thesis dissertation, 12 for streaming audio, 13 for streaming video, or 14 for audio book. (optional)
* @param  string $searchtype Type of search. Search types are any, contains, exactmatch, beginswith, proximity, exactphrase and advanced. It is also valid to use 0 for any, 1 for contains, 2 for exactmatch, 3 for beginswith, 4 for proximity, 5 for exactphrase or 6 for advanced.  searchtype is an optional parameter and defaults to contains if not provided.  For more information on the search types, see [Using Search Types](https://developer.ebsco.com/guides/overviewsearch/) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidTitlesGetAsyncWithHttpInfo($custid, $search, $searchfield, $orderby, $count, $offset, $x_api_key, $selection = null, $resourcetype = null, $searchtype = null)
    {
        $returnType = '\Swagger\Client\Model\Titles';
        $request = $this->custidTitlesGetRequest($custid, $search, $searchfield, $orderby, $count, $offset, $x_api_key, $selection, $resourcetype, $searchtype);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
$responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'custidTitlesGet'
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  string $search Search Term.  Keyword search that is applied to limit the results to titles that have the search term in the search field. (required)
* @param  string $searchfield Field to search.  Valid values are titlename, publisher, isxn, and subject.  It is also valid to use 0 for title name, 1 for publisher, 2 for isxn or 3 for subject. (required)
* @param  string $orderby Valid values are relevance or titlename.  Default is relevance. (required)
* @param  int $count The maximum number of results to return in the response. (required)
* @param  int $offset Page Offset (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  string $selection Limits the results.  Valid values are all, selected, notselected and orderedthroughebsco.  It is also valid to use 0 for all, 1 for selected, 2 for notselected, or 3 for ordered through EBSCO.  When you filter by all(0), the total results count takes selected and not selected into consideration. (optional)
* @param  string $resourcetype Type of resource. Valid values are all, journal, newsletter, report, proceedings, website, newspaper, unspecified, book, bookseries, database, thesisdissertation, streamingaudio, streamingvideo, and audiobook.  It is also valid to use 0 for all, 1 for journal, 2 for newsletter, 3 for report, 4 for proceedings, 5 for website, 6 for newspaper, 7 for unspecified, 8 for book, 9 for book series, 10 for database, 11 for thesis dissertation, 12 for streaming audio, 13 for streaming video, or 14 for audio book. (optional)
* @param  string $searchtype Type of search. Search types are any, contains, exactmatch, beginswith, proximity, exactphrase and advanced. It is also valid to use 0 for any, 1 for contains, 2 for exactmatch, 3 for beginswith, 4 for proximity, 5 for exactphrase or 6 for advanced.  searchtype is an optional parameter and defaults to contains if not provided.  For more information on the search types, see [Using Search Types](https://developer.ebsco.com/guides/overviewsearch/) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function custidTitlesGetRequest($custid, $search, $searchfield, $orderby, $count, $offset, $x_api_key, $selection = null, $resourcetype = null, $searchtype = null)
    {
// verify the required parameter 'custid' is set
        if ($custid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custid when calling custidTitlesGet'
            );
        }
// verify the required parameter 'search' is set
        if ($search === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $search when calling custidTitlesGet'
            );
        }
// verify the required parameter 'searchfield' is set
        if ($searchfield === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchfield when calling custidTitlesGet'
            );
        }
// verify the required parameter 'orderby' is set
        if ($orderby === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $orderby when calling custidTitlesGet'
            );
        }
// verify the required parameter 'count' is set
        if ($count === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling custidTitlesGet'
            );
        }
// verify the required parameter 'offset' is set
        if ($offset === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling custidTitlesGet'
            );
        }
// verify the required parameter 'x_api_key' is set
        if ($x_api_key === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_api_key when calling custidTitlesGet'
            );
        }
$resourcePath = '/{custid}/titles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// query params
if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search);
        }
// query params
if ($searchfield !== null) {
            $queryParams['searchfield'] = ObjectSerializer::toQueryValue($searchfield);
        }
// query params
if ($selection !== null) {
            $queryParams['selection'] = ObjectSerializer::toQueryValue($selection);
        }
// query params
if ($resourcetype !== null) {
            $queryParams['resourcetype'] = ObjectSerializer::toQueryValue($resourcetype);
        }
// query params
if ($searchtype !== null) {
            $queryParams['searchtype'] = ObjectSerializer::toQueryValue($searchtype);
        }
// query params
if ($orderby !== null) {
            $queryParams['orderby'] = ObjectSerializer::toQueryValue($orderby);
        }
// query params
if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count);
        }
// query params
if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
// header params
if ($x_api_key !== null) {
            $headerParams['x-api-key'] = ObjectSerializer::toHeaderValue($x_api_key);
        }
// path params
if ($custid !== null) {
            $resourcePath = str_replace(
                '{' . 'custid' . '}',
                ObjectSerializer::toPathValue($custid),
                $resourcePath
            );
        }
// body params
        $_tempBody = null;
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation custidTitlesKbidGet
*
* @param  string $custid EBSCO Customer ID (required)
* @param  int $kbid Title ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TitleManaged
     */
    public function custidTitlesKbidGet($custid, $kbid, $x_api_key)
    {
        list($response) = $this->custidTitlesKbidGetWithHttpInfo($custid, $kbid, $x_api_key);
        return $response;
    }

    /**
     * Operation custidTitlesKbidGetWithHttpInfo
*
* @param  string $custid EBSCO Customer ID (required)
* @param  int $kbid Title ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TitleManaged, HTTP status code, HTTP response headers (array of strings)
     */
    public function custidTitlesKbidGetWithHttpInfo($custid, $kbid, $x_api_key)
    {
        $returnType = '\Swagger\Client\Model\TitleManaged';
        $request = $this->custidTitlesKbidGetRequest($custid, $kbid, $x_api_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

$responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];


        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 200:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\TitleManaged',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
case 200 :$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\TitleCustom',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
case 0:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\Errors',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation custidTitlesKbidGetAsync
     *
     * 
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  int $kbid Title ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidTitlesKbidGetAsync($custid, $kbid, $x_api_key)
    {
        return $this->custidTitlesKbidGetAsyncWithHttpInfo($custid, $kbid, $x_api_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation custidTitlesKbidGetAsyncWithHttpInfo
     *
     * 
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  int $kbid Title ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidTitlesKbidGetAsyncWithHttpInfo($custid, $kbid, $x_api_key)
    {
        $returnType = '\Swagger\Client\Model\TitleManaged';
        $request = $this->custidTitlesKbidGetRequest($custid, $kbid, $x_api_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
$responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'custidTitlesKbidGet'
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  int $kbid Title ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function custidTitlesKbidGetRequest($custid, $kbid, $x_api_key)
    {
// verify the required parameter 'custid' is set
        if ($custid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custid when calling custidTitlesKbidGet'
            );
        }
// verify the required parameter 'kbid' is set
        if ($kbid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $kbid when calling custidTitlesKbidGet'
            );
        }
// verify the required parameter 'x_api_key' is set
        if ($x_api_key === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_api_key when calling custidTitlesKbidGet'
            );
        }
$resourcePath = '/{custid}/titles/{kbid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// header params
if ($x_api_key !== null) {
            $headerParams['x-api-key'] = ObjectSerializer::toHeaderValue($x_api_key);
        }
// path params
if ($custid !== null) {
            $resourcePath = str_replace(
                '{' . 'custid' . '}',
                ObjectSerializer::toPathValue($custid),
                $resourcePath
            );
        }
// path params
if ($kbid !== null) {
            $resourcePath = str_replace(
                '{' . 'kbid' . '}',
                ObjectSerializer::toPathValue($kbid),
                $resourcePath
            );
        }
// body params
        $_tempBody = null;
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidTitlesPost
*
* @param  string $custid EBSCO Customer ID (required)
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\CustomTitlePayload $body JSON POST title details payload.  The titleName and pubType elements are required in the custom title payload. (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CustomTitleResponse
     */
    public function custidVendorsVendoridPackagesPackageidTitlesPost($custid, $vendorid, $packageid, $x_api_key, $body = null)
    {
        list($response) = $this->custidVendorsVendoridPackagesPackageidTitlesPostWithHttpInfo($custid, $vendorid, $packageid, $x_api_key, $body);
        return $response;
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidTitlesPostWithHttpInfo
*
* @param  string $custid EBSCO Customer ID (required)
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\CustomTitlePayload $body JSON POST title details payload.  The titleName and pubType elements are required in the custom title payload. (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CustomTitleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function custidVendorsVendoridPackagesPackageidTitlesPostWithHttpInfo($custid, $vendorid, $packageid, $x_api_key, $body = null)
    {
        $returnType = '\Swagger\Client\Model\CustomTitleResponse';
        $request = $this->custidVendorsVendoridPackagesPackageidTitlesPostRequest($custid, $vendorid, $packageid, $x_api_key, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

$responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];


        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 200:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\CustomTitleResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
case 0:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\Errors',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidTitlesPostAsync
     *
     * 
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\CustomTitlePayload $body JSON POST title details payload.  The titleName and pubType elements are required in the custom title payload. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidVendorsVendoridPackagesPackageidTitlesPostAsync($custid, $vendorid, $packageid, $x_api_key, $body = null)
    {
        return $this->custidVendorsVendoridPackagesPackageidTitlesPostAsyncWithHttpInfo($custid, $vendorid, $packageid, $x_api_key, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation custidVendorsVendoridPackagesPackageidTitlesPostAsyncWithHttpInfo
     *
     * 
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\CustomTitlePayload $body JSON POST title details payload.  The titleName and pubType elements are required in the custom title payload. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function custidVendorsVendoridPackagesPackageidTitlesPostAsyncWithHttpInfo($custid, $vendorid, $packageid, $x_api_key, $body = null)
    {
        $returnType = '\Swagger\Client\Model\CustomTitleResponse';
        $request = $this->custidVendorsVendoridPackagesPackageidTitlesPostRequest($custid, $vendorid, $packageid, $x_api_key, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
$responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'custidVendorsVendoridPackagesPackageidTitlesPost'
     *
* @param  string $custid EBSCO Customer ID (required)
* @param  int $vendorid Vendor ID (required)
* @param  int $packageid Package ID (required)
* @param  string $x_api_key Unique code assigned by EBSCO to grant you access to this API.  The API key needs to be a header parameter for every operation in order to access this API. Your production API key will not grant you access to the API through the interactive documentation. You will need a sandbox API key to use the interactive documentation.  If you require a sandbox API key, please contact EBSCO customer support. (required)
* @param  \Swagger\Client\Model\CustomTitlePayload $body JSON POST title details payload.  The titleName and pubType elements are required in the custom title payload. (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function custidVendorsVendoridPackagesPackageidTitlesPostRequest($custid, $vendorid, $packageid, $x_api_key, $body = null)
    {
// verify the required parameter 'custid' is set
        if ($custid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custid when calling custidVendorsVendoridPackagesPackageidTitlesPost'
            );
        }
// verify the required parameter 'vendorid' is set
        if ($vendorid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendorid when calling custidVendorsVendoridPackagesPackageidTitlesPost'
            );
        }
// verify the required parameter 'packageid' is set
        if ($packageid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $packageid when calling custidVendorsVendoridPackagesPackageidTitlesPost'
            );
        }
// verify the required parameter 'x_api_key' is set
        if ($x_api_key === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_api_key when calling custidVendorsVendoridPackagesPackageidTitlesPost'
            );
        }
$resourcePath = '/{custid}/vendors/{vendorid}/packages/{packageid}/titles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// header params
if ($x_api_key !== null) {
            $headerParams['x-api-key'] = ObjectSerializer::toHeaderValue($x_api_key);
        }
// path params
if ($custid !== null) {
            $resourcePath = str_replace(
                '{' . 'custid' . '}',
                ObjectSerializer::toPathValue($custid),
                $resourcePath
            );
        }
// path params
if ($vendorid !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorid' . '}',
                ObjectSerializer::toPathValue($vendorid),
                $resourcePath
            );
        }
// path params
if ($packageid !== null) {
            $resourcePath = str_replace(
                '{' . 'packageid' . '}',
                ObjectSerializer::toPathValue($packageid),
                $resourcePath
            );
        }
// body params
        $_tempBody = null;
if (isset($body)) {
            $_tempBody = $body;
        }
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

/**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
